"""
ヒープソート (Heap Sort) の実装

ヒープ（優先度付きキュー）を使った効率的なソートアルゴリズム

計算量:
- 最良: O(N log N)
- 平均: O(N log N)
- 最悪: O(N log N)

空間計算量: O(1) (in-place ソート)

特徴:
- 安定ソートではない（同値要素の順序が保証されない）
- in-place ソート（追加メモリがほぼ不要）
- 常に O(N log N) の性能を保証
- 実装が複雑で定数倍が大きい
"""


def heapify(a: list[int], i: int, N: int) -> None:
    """
    配列の部分木を最大ヒープにする（ヒープ条件を満たすように修復する）

    前提条件: インデックス N-1 までの配列 a[0:N] がヒープの対象

    ヒープの条件（最大ヒープ）:
    - 親ノード >= 子ノード

    配列での親子関係:
    - ノード i の左の子ノード: 2*i + 1
    - ノード i の右の子ノード: 2*i + 2
    - ノード i の親ノード: (i - 1) // 2

    Args:
        a: ソート対象の配列
        i: ヒープ化する部分木のルートノード
        N: 配列の有効範囲（a[0:N] の範囲をヒープとして扱う）

    手順:
    1. 自分と子ノードの中で最大値を探す
    2. 最大値が子ノードなら、その子と交換
    3. 交換後、その子の位置で再帰的に heapify
    """
    # 左の子ノードのインデックス
    child1 = i * 2 + 1

    # 子ノードが存在しない場合は終了
    if child1 >= N:
        return

    # 子ノードの選択
    # 左の子と右の子を比較して、大きい方の子ノードを選ぶ
    if child1 + 1 < N and a[child1 + 1] > a[child1]:
        child1 += 1  # 右の子を選択

    # ヒープ条件が満たされている場合（親 >= 子）
    if a[child1] <= a[i]:
        return

    # swap（親と最大の子を交換）
    a[i], a[child1] = a[child1], a[i]

    # 再帰的にヒープ化
    # 交換後、子の位置でもヒープ条件が満たされるように修復
    heapify(a, child1, N)


def heap_sort(a: list[int]) -> None:
    """
    配列をヒープソートでソートする (in-place)

    手順:
    フェーズ1: 配列全体をヒープに変換する
    - 最後の非葉ノード（N//2 - 1）から0に向かってヒープ化
    - 最後の非葉ノードから処理することで、効率的にヒープを構築

    フェーズ2: ソート処理：1個ずつ最大値を pop してソートする
    - ヒープの最大値（a[0]）を末尾に移動
    - ヒープサイズを1減らす
    - 再度 heapify して最大ヒープを修復
    - これを繰り返す

    Args:
        a: ソート対象の配列

    例:
        a = [5, 2, 8, 1, 9]
        heap_sort(a) -> a = [1, 2, 5, 8, 9]
    """
    N = len(a)

    # === フェーズ1: 配列全体をヒープに変換する ===
    # 最後の非葉ノードから順番にヒープ化
    # 非葉ノードは子を持つので、ヒープ条件の修復が必要
    # 最後の非葉ノード = N // 2 - 1
    for i in range(N // 2 - 1, -1, -1):
        heapify(a, i, N)

    # この時点で配列は最大ヒープになっている
    # a[0] が最大値

    # === フェーズ2: ソート処理：1個ずつ最大値を pop してソートする ===
    for i in range(N - 1, 0, -1):
        # ヒープの最大値（a[0]）を末尾（a[i]）と交換
        # これにより最大値が配列の最後に確定位置へ移動する
        a[0], a[i] = a[i], a[0]

        # ヒープサイズを1減らして（交換した末尾は除外）、
        # 再度ルートをヒープ化して最大ヒープを修復
        heapify(a, 0, i)

    # 配列が昇順にソートされて完成
